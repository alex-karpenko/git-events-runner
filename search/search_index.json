{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#briefly","title":"Briefly","text":"<p>Git Events Runner is a Kubernetes operator to trigger <code>Jobs</code> with the Git repository content in the job's container. In other words it provides way to run code inside a Kubernetes cluster based on content of the Git repository commit in response to changes in the repository or triggered by a webhook.</p>"},{"location":"#what-is-under-the-hood","title":"What is under the hood","text":"<p><code>Git Events Runner</code> provides several custom resources (CRDs) to define such entities as:</p> <ul> <li><code>Sources</code> - URI and auth parameters of git repositories which should be watching and using to run <code>Actions</code>.</li> <li><code>Triggers</code> - conditions and restrictions of changes in <code>Sources</code> which triggers <code>Actions</code>: which repos, branches or   tags to watch and how often.   It includes scheduled and webhook triggers.</li> <li><code>Actions</code> - predefined configurations of K8s <code>Job</code> to run as reaction to fired  <code>Trigger</code>.</li> </ul> <p>Everything is glued by dedicated Kubernetes controller inside a cluster.</p>"},{"location":"#where-it-applies","title":"Where it applies","text":"<ul> <li>Various Continues Deployment (CD) processes, where Kubernetes resources are involved.</li> <li>Running periodic tasks in Kubernetes, based on code in Git repo.</li> <li>Triggering tasks in Kubernetes by webhooks, based on code in Git repo.</li> <li>Replacement of CI/CD functionality, provided by repository vendor (GitHub actions, for example)   where direct access to Kubernetes or cloud resources is needed but with guarantied permissions restrictions.</li> </ul> <p>Each item above implies using of approved code from some configured Git repository, branch, tag or even commit.</p>"},{"location":"bugs/","title":"Known Bugs","text":""},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#011-2024-06-01","title":"0.1.1 - 2024-06-01","text":""},{"location":"changelog/#details","title":"Details","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Add subcommand to dump default dynamic config by @alex-karpenko in #8</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Bump requests from 2.31.0 to 2.32.2 by @dependabot[bot] in #4</li> <li>Push images to docker.io registry by @alex-karpenko in #6</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fix links in the README by @alex-karpenko</li> <li>Change action-worker base image to Ubuntu 24.04 by @alex-karpenko in #7</li> </ul>"},{"location":"changelog/#new-contributors","title":"New Contributors","text":"<ul> <li>@dependabot[bot] made their first contribution in #4</li> </ul>"},{"location":"changelog/#010-2024-05-24","title":"[0.1.0] - 2024-05-24","text":""},{"location":"changelog/#details_1","title":"Details","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>First beta implementation by @alex-karpenko in #2</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fix error in release workflow by @alex-karpenko in #5</li> <li>Fix release workflow permissions by @alex-karpenko</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Remove changelog updating from the release workflow by @alex-karpenko</li> </ul>"},{"location":"lic/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2024 Oleksii Karpenko\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#in-work","title":"In work","text":"<ul> <li>chart: update to specify container registry and use docker.io by default</li> <li>action:<ul> <li>config to restrict the maximum number of running acton jobs;</li> <li>config to restrict jobs' duration;</li> <li>config parameters to specify node affinity, toleration, annotations and additional labels for action job.</li> </ul> </li> </ul>"},{"location":"roadmap/#next-release","title":"Next release","text":"<ul> <li>gitrepo: extend file sensor to use globs instead of single file</li> <li>refactor: improve logging, make it more formal and short, with just relevant info only</li> <li>controller: tracing</li> <li>controller: metrics</li> </ul>"},{"location":"roadmap/#wishes","title":"Wishes","text":"<ul> <li>tests: automate everything possible</li> <li>refactor: looks like scheduler shouldn't be under RwLock because it's <code>add</code> method uses internal mutability</li> <li>gitrepo: update to use <code>gix</code> instead of <code>git2</code>, if possible</li> <li>hooks: implement hook requests rate control/throttling</li> <li>hooks/gitrepo: rework secrets cache to watch requested secrets and update it on changes</li> <li>cli: deploy, config, get state, remove</li> <li>cli: configure webhook auth secrets and store them as hashes</li> <li>hooks: tls listener for webhooks</li> <li>gitrepo: add support for private keys with passphrase</li> <li>gitrepo: use Mozilla CA bundle instead of system and build controller/cloner images <code>FROM scratch</code></li> <li>controller: get rid of kubert dependency</li> </ul>"},{"location":"roadmap/#done","title":"Done","text":"<ul> <li>images: publish images to docker hub</li> <li>images: update default action-worker image to use the latest Ubuntu LTS version</li> <li>chart/cli: Make new subcommand to dump out default config and verify it in the chart as part of CI</li> </ul>"},{"location":"guides/concepts/","title":"Core concepts and components","text":""},{"location":"guides/concepts/#controller","title":"Controller","text":"<p>Typically, it's deployed to Kubernetes cluster as a Deployment resource using pre-built Docker image. Its responsibility is to:</p> <ul> <li>Watch on custom resources (triggers, actions, sources) and hold a local resources'   state (for performance purpose).</li> <li>Watch on changes of ScheduleTrigger and update schedules if it's   changed.</li> <li>Periodically run tasks (according to triggers' schedules) to check for changes of ScheduleTriggers' sources.</li> <li>Run web server to handle webhook requests to check for changes of WebhookTriggers' sources.</li> <li>Create Kubernetes Job to apply configured action if a triggers' source is changed (or in some other circumstances   depending on triggers' config).</li> <li>Watch on Jobs which controller has run to provide Jobs' final state into the logs.</li> <li>Run utility web server to handle requests for liveness and readiness probes, and to provide metrics.</li> <li>Watch on ConfigMap with dynamic controllers' config and reload dynamic configuration in case of changes.</li> <li>Hold leader lease and do leader election with respect to all pods of the controller.</li> <li>Watch on signals to shut down gracefully if termination was requested.</li> </ul>"},{"location":"guides/concepts/#high-availability","title":"High availability","text":"<p>It's possible to run multiple instances of the controller. Moreover, such a config is preferred for production environments. Controller manages single instance where ScheduleTriggers should be executed, it uses Kubernetes Lease resource to ensure fast and reliable leaders' election.</p> <p>If at least two controllers' instances are running, in case of failures (pod evicted, node crashed, etc.) there is a builtin mechanism to smoothly move triggers' scheduling to another available instance.</p> <p>One more point to pay attention to is WebhookTriggers' availability. Since this kind of trigger is actually a web server running on all controllers' instances. Having at least two controllers' instances helps do workload balancing and provides a classic mechanism of failure protection because Kubernetes Service always forwards traffic to available pods only.</p>"},{"location":"guides/concepts/#custom-resources","title":"Custom resources","text":"<p>Detailed references to all resources is in the separate section Resources. But few aspects should be mentioned:</p>"},{"location":"guides/concepts/#active-vs-passive-resources","title":"Active vs passive resources","text":"<p>ScheduleTrigger is the only active resource that has its own state outside the cluster and initiates periodic tasks for checking sources.</p> <p>All other resources are either a passive WebhookTrigger (it waits for external http requests to do any activity) or supplementary for triggers (sources and actions - triggers use them to interact with repos or run jobs).</p>"},{"location":"guides/concepts/#namespaced-vs-cluster-wide-resources","title":"Namespaced vs cluster-wide resources","text":"<p>Besides introduction, we have to know the following:</p> <ul> <li>ClusterGitRepo can refer secrets in any namespace, but allowing access to secrets outside of controller's namespace is   the responsibility of the cluster administrator.   Provided Helm chart may facilitate this.</li> <li>ClusterAction can override the source used in its Job (this is a feature of both actions resources), but it can use   ClusterGitRepo only to avoid cross-namespace access to GitRepo in multi-tenant environments.</li> </ul>"},{"location":"guides/concepts/#crds-manifests","title":"CRDs manifests","text":"<p><code>git-events-runner</code> Helm chart contains the latest actual bundle of CRD manifests.</p> <p>Besides that, it's possible to get CRDs right from the controllers binary. The easiest way is to run controller's Docker image with <code>crds</code> parameter:</p> <pre><code>docker run --rm ghcr.io/alex-karpenko/git-events-runner/git-events-runner:latest crds\n</code></pre> <p>Use any valid version/tag instead of <code>latest</code> to get the specific version of manifests, if necessary.</p>"},{"location":"guides/concepts/#images-and-binaries","title":"Images and binaries","text":"<p>Git Events Runner uses three types of images to run:</p> <ul> <li>git-events-runner: pre-built image with single controller's binary, without shell, package managers, etc.;</li> <li>gitrepo-cloner: pre-built image with single binary of utility to safely clone git repositories, it's used in the   init container of action Jobs, without shell, package managers, etc.;</li> <li>action-worker: Job's runtime image, which contains everything you need to do actual work with cloned code.</li> </ul> <p>As for action-worker, you can use any image you need: existing one from any repository (<code>bash</code> or <code>ubuntu</code> for example), anything built by yourself or default one provided in this project. Anyway, what command to run on start you provide in actions' config.</p> <p>There is default action-worker image built from this Dockerfile, it's based on Ubuntu 22.04 and includes the set of typically used CD tools: Python, AWS CLI, Helm, kubectl, curl.</p> <p>All Dockerfiles of this project are there: https://github.com/alex-karpenko/git-events-runner/tree/main/docker-build</p>"},{"location":"guides/concepts/#action-job-internals","title":"Action Job internals","text":"<p>When a trigger discovers that repo was changed, it creates a classic Kubernetes Job to run Action because action is a single-shot piece of work.</p> <p>Action resources provide way to slightly customize jobs, but in general configuration is:</p> <ul> <li>Single <code>initContainer</code> runs <code>gitrepo-cloner</code> image to clone needed repo/commit to predefined volume.</li> <li>Single <code>container</code> runs <code>action-worker</code> image to do actual work.</li> <li>Both containers mount shared <code>emptyDir</code> volume with content of the git repo/commit, worker container uses it as a   Pods' workdir.</li> <li>Worker container has set of predefined environment variables with prefix in names (default is <code>ACTION_JOB_</code>) with   some actual runtime parameters that can be useful in workers.   Look into the detailed actions reference for the full list of variables with descriptions.</li> <li>Job has a zero backoff limit and single parallelism to ensure running only once.</li> </ul>"},{"location":"guides/concepts/#jobs-environment-variables","title":"Jobs' environment variables","text":"<p>As mentioned above, <code>ACTION_JOB_</code> is just default prefix and may be configured to anything else.</p> Variable name Mandatory Description ACTION_JOB_WORKDIR Yes Worker container workdir (folder where source repo is cloned) ACTION_JOB_TRIGGER_SOURCE_KIND Yes Kind of the triggers' source (Gitrepo, ClusterGitRepo) ACTION_JOB_TRIGGER_SOURCE_NAME Yes Name of the triggers' source. ACTION_JOB_TRIGGER_SOURCE_NAMESPACE No Namespace of the triggers' source (for GitRepo only). ACTION_JOB_TRIGGER_SOURCE_COMMIT Yes Commit hash which is cloned into workdir. ACTION_JOB_TRIGGER_SOURCE_REF_TYPE Yes Type of the triggers' repo reference which is configured to watch on (branch, tag, commit) ACTION_JOB_TRIGGER_SOURCE_REF_NAME Yes Name of the triggers' repo reference. ACTION_JOB_ACTION_SOURCE_KIND No Kind of the actions' overridden source. ACTION_JOB_ACTION_SOURCE_NAME No Name of the actions' overridden source. ACTION_JOB_ACTION_SOURCE_NAMESPACE No Namespace on the actions' overridden source. ACTION_JOB_ACTION_SOURCE_REF_TYPE No Reference type of the actions' overridden source. ACTION_JOB_ACTION_SOURCE_REF_NAME No Name of the actions' overridden source. <p>Details about <code>source override</code> feature can be found in the detailed documentation. </p>"},{"location":"guides/config/","title":"Configuration","text":"<p>The Helm chart has two dedicated controllers' configuration sections, pretty well commented in the <code>values.yaml</code>:</p> <ul> <li><code>controllerOptions</code>: defines values of some controllers' command line options.</li> <li><code>runtimeConfig</code>: defines content of the ConfigMap with dynamic controllers' config, or, in other words, with   overridden defaults.   It will be reloaded by controller each time it's changed.</li> </ul> <p>Let's explain all of them with some details.</p>"},{"location":"guides/config/#controller-options","title":"Controller options","text":""},{"location":"guides/config/#loglevel","title":"logLevel","text":"<p>Allowed values: <code>info</code>, <code>debug</code>.</p> <p>Controller hs three possible log levels: debug, info, warning. If nothing is specified (this is equivalent to omit both <code>--debug</code> and <code>--verbose</code> command line options) the default level is warning. Using this parameter, you can change log level.</p>"},{"location":"guides/config/#leaderlease","title":"leaderLease","text":"<p>This section declares the parameters of using Lease resource to manage leader elections. There are two parameters:</p> <ul> <li><code>duration</code>: leader election will be started if the current leaseholder doesn't confirm its lock during this time (in   seconds).</li> <li><code>grace</code>: leaseholder re-confirms (renews) its lock each this interval (in seconds).</li> </ul> <p>Logically, grace should be less than duration and the difference between these two parameters should be enough to re-confirm lock.</p>"},{"location":"guides/config/#scheduleparallelism-webhooksparallelism","title":"scheduleParallelism, webhooksParallelism","text":"<p>Allowed values: integer from 1 to 255.</p> <p>These parameters set, for each type of triggers, the maximum number of parallel tasks that the controller runs to watch for changes in the sources.</p> <p>Important: This is not a maximum number of simultaneous action jobs. This is a way to restrict controller only from running of huge number of simultaneous source verification tasks. So there is no way (at least now) to restrict number of action jobs.</p>"},{"location":"guides/config/#secretscachetime","title":"secretsCacheTime","text":"<p>This parameter specifies the maximum number of seconds to hold values in the cache of secrets.</p> <p>Controller resolves content of the secrets each time it needs secret value (for example, WebhookTrigger can use auth token stored in a secret). To eliminate Kubernetes API overloading by huge number of requests for secret values, the controller has some kind of shared cache for secrets. It holds only vales used by controller.</p>"},{"location":"guides/config/#sourceclonefolder","title":"sourceCloneFolder","text":"<p>This section defines which folder (<code>mountPath</code>) will be used inside the controller to clone content of the sources during periodic verification for changes.</p> <p>At the same time, parameter <code>volumeName</code> defines name of the Pods' volume, which should be used for that folder. Helm chart defines controllers' Pod with this volume of type <code>emptyDir</code>.</p>"},{"location":"guides/config/#runtime-config","title":"Runtime config","text":""},{"location":"guides/config/#trigger","title":"trigger","text":"<p>Defines triggers defaults:</p> <ul> <li><code>webhook.defaultAuthHeader</code>: default header name with authentication token in a WebhookTrigger request. May be changed   in the trigger config. Default is <code>x-trigger-auth</code>.</li> </ul>"},{"location":"guides/config/#action","title":"action","text":"<p>This section defines lots of defaults of action jobs.</p> Parameter name Default value Description ttlSecondsAfterFinished 7200 Default time to leave of Job after finishing. After this time Jobs will be removed from the cluster with its Pod. Useful fo debug purpose. defaultServiceAccount <code>{{ fullname }}-action-job</code> Default service account name for action jobs. Actual default depends on release name and <code>fullnameOverride</code> global parameter. workdir.mountPath /action_workdir Default folder to clone source content to. It's used for both cloner and worker container. workdir.volumeName action-workdir Volume name of workdir <code>emptyDir</code> volume. containers.cloner.name action-cloner Name of the source cloner initContainer in the action Job. containers.cloner.image ghcr.io/alex-karpenko/git-events-runner/gitrepo-cloner:{{ .Chart.AppVersion }} Default image to use for source cloner container. containers.worker.name action-worker Name of the action worker container in the action Job. containers.worker.image ghcr.io/alex-karpenko/git-events-runner/action-worker:{{ .Chart.AppVersion }} Default image to use for the action worker container. containers.worker.variablesPrefix ACTION_JOB_ Prefix for environment variables of the action worker container, that controller creates to pass trigger and sources parameters."},{"location":"guides/config/#command-line-parameters","title":"Command line parameters","text":"<p>Controller application has three subcommands:</p> <ul> <li><code>crds</code>: to print CRD manifests to the stdout.   It's useful to install CRD declarations to your cluster directly.   It has no additional options.</li> <li><code>config</code>: to print a default dynamic config to the stdout.   It's useful to get base config and modify parts you want to customize.   Has only one optional parameter <code>--helm-template</code> to dump some templates instead of default values:   this option is useful in CI/CD pipelines to automate Helm chart linting and templating.</li> <li><code>run</code>: to run controller, all command line parameters are optional and have defaults.   All of them are described as a static configuration options above in this section.</li> </ul> <pre><code>docker run --rm ghcr.io/alex-karpenko/git-events-runner/git-events-runner:latest --help\n\nKubernetes operator to run Jobs on events from Git\n\nUsage: git-events-runner &lt;COMMAND&gt;\n\nCommands:\n  crds    Print CRD definitions to stdout\n  config  Print default dynamic config YAML to stdout\n  run     Run K8s controller\n  help    Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n</code></pre> <pre><code>docker run --rm ghcr.io/alex-karpenko/git-events-runner/git-events-runner:latest run --help\n\nRun K8s controller\n\nUsage: git-events-runner run [OPTIONS]\n\nOptions:\n  -w, --webhooks-port &lt;WEBHOOKS_PORT&gt;\n          Port to listen on for webhooks [default: 8080]\n  -u, --utility-port &lt;UTILITY_PORT&gt;\n          Port to listen on for utilities web [default: 3000]\n      --webhooks-parallelism &lt;WEBHOOKS_PARALLELISM&gt;\n          Maximum number of webhook triggers running in parallel [default: 16]\n      --schedule-parallelism &lt;SCHEDULE_PARALLELISM&gt;\n          Maximum number of schedule triggers running in parallel [default: 16]\n      --secrets-cache-time &lt;SECRETS_CACHE_TIME&gt;\n          Seconds to cache secrets for [default: 60]\n      --source-clone-folder &lt;SOURCE_CLONE_FOLDER&gt;\n          Path (within container) to clone repo to [default: /tmp/git-events-runner]\n      --config-map-name &lt;CONFIG_MAP_NAME&gt;\n          Name of the ConfigMap with dynamic controller config [default: git-events-runner-config]\n      --leader-lease-name &lt;LEADER_LEASE_NAME&gt;\n          Name of the Lease for leader locking [default: git-events-runner-leader-lock]\n      --leader-lease-duration &lt;LEADER_LEASE_DURATION&gt;\n          Leader lease duration, seconds [default: 30]\n      --leader-lease-grace &lt;LEADER_LEASE_GRACE&gt;\n          Leader lease grace interval, seconds [default: 20]\n  -d, --debug\n          Enable extreme logging (debug)\n  -v, --verbose\n          Enable additional logging (info)\n  -h, --help\n          Print help\n</code></pre>"},{"location":"guides/config/#gitrepo-cloner-options","title":"gitrepo-cloner options","text":"<p>Usually you don't use this image (or app) directly, but the controller runs Jobs with <code>gitrepo-cloner</code> init image. It doesn't have configuration files but command line options only.</p> <p>Just for the sake of curiosity or for debugging purpose:</p> <pre><code>docker run --rm ghcr.io/alex-karpenko/git-events-runner/gitrepo-cloner:latest --help\n\nGit repo cloner, supplementary tool for git-events-runner operator\n\nUsage: gitrepo-cloner [OPTIONS] --kind &lt;SOURCE_KIND&gt; --source &lt;SOURCE_NAME&gt; --destination &lt;DESTINATION&gt; &lt;--branch &lt;BRANCH&gt;|--tag &lt;TAG&gt;|--commit &lt;COMMIT&gt;&gt;\n\nOptions:\n  -k, --kind &lt;SOURCE_KIND&gt;         Source kind\n  -s, --source &lt;SOURCE_NAME&gt;       Source name\n  -b, --branch &lt;BRANCH&gt;            Branch name\n  -t, --tag &lt;TAG&gt;                  Tag name\n  -c, --commit &lt;COMMIT&gt;            Commit hash\n  -d, --destination &lt;DESTINATION&gt;  Destination folder\n  -p, --preserve-git-folder        Don't remove .git folder after clone\n      --debug                      Set log level to debug\n  -h, --help                       Print help\n  -V, --version                    Print version\n</code></pre> <p>Note: <code>--branch</code>, <code>--tag</code> and <code>--commit</code> options are mutually exclusive, but one of them is mandatory;</p>"},{"location":"guides/install/","title":"Installation","text":"<p>The easiest and the most elaborated way to install Git Events Runner controller with reasonable defaults and pretty customizable config is using Helm chart. This way uses pre-built project Docker images and installs controller as deployment resources to the Kubernetes cluster.</p> <p>At the same time, you can build and use your own Docker images with the same Helm chart or build and run controller locally (for example, for debug or development purpose).</p>"},{"location":"guides/install/#helm","title":"Helm","text":"<p>To use the provided Helm chart, add Helm repository and install release as below:</p> <pre><code># Add repo\nhelm repo add alex-karpenko https://alex-karpenko.github.io/helm-charts\nhelm repo update\n\n# Deploy new release to the git-events-runner namespace\n# with default config\nhelm install git-events-runner alex-karpenko/git-events-runner \\\n    --namespace git-events-runner --create-namespace\n</code></pre> <p>The usual way to use Git Events Runner in a single tenant cluster is to deploy it to the dedicated namespace where the controller runs and all other supplementary resources are created. As well as custom resources like sources, triggers and actions usually reside in the same namespace with their secrets. Such an approach facilitates secrets management and RBAC tuning.</p> <p>For the multi-tenant clusters, you also can use the same chart, but probably some additional customization is needed.</p>"},{"location":"guides/install/#custom-resources-definitions","title":"Custom resources definitions","text":"<p>Provided Helm chart contains CRD manifests in the <code>crds/</code> folder. During the first time installation, these CRDs will be deployed to the cluster, but all consecutive upgrades won't upgrade CRDs, reason is described in the Helm documentation.</p> <p>If you need to manipulate CRDs manually, pull the chart, extract it and deploy or remove CRDs as you need:</p> <pre><code># Extarct chart into the ./git-events-runner froler  \nhelm pull alex-karpenko/git-events-runner --untar --untardir ./\n\n# Deploy/upgrade all CRDs in the cluster\nkubectl apply -f git-events-runner/crds/\n\n# Remove all CRDs from the cluster\nkubectl delete -f git-events-runner/crds/\n</code></pre> <p>If you're going to uninstall controller and CRDs, delete all custom resources before uninstalling the Helm release.</p>"},{"location":"guides/install/#deployment-customization","title":"Deployment customization","text":"<p>As usual, Helm release can be tuned using customized <code>values</code> file or via <code>--set</code> command-line options. Provided chart has pretty well commented <code>values.yaml</code>.</p> <p>We want to point out to some important parts of a release configuration.</p>"},{"location":"guides/install/#replicas","title":"Replicas","text":"<p>As mentioned before, Git Events Runner supports running several replicas at once, so if you need high-availability config, you have to set <code>replicaCount</code> to something greater than 1, usually 2 is reasonable starting choice for production environment to ensure HA and don't waste resources. Single replica is good for development and testing.</p> <p>Horizontal Pods Autoscaler (HPA) is option that available in the chart and disabled by default, configure and enable it in the <code>autoscaling</code> section if needed.</p>"},{"location":"guides/install/#rbac-and-service-accounts","title":"RBAC and service accounts","text":"<p>The chart provides a way to create controllers' and jobs' service accounts (SA) as well as default set of roles, cluster roles and necessary bindings to ensure working setup with minimal needed permissions. The recommended way to extend permissions of the controller or action jobs is to create custom roles and bind them with existing service accounts.</p> <p>The default name of the controllers' service account is its <code>{{ fullname }}</code> template: usually this is release name or <code>fullnameOverride</code> value (if specified). The default name of the jobs' service account id <code>{{ fullname }}-action-job</code>. So if you need additional permissions for controller of jobs, you can attach it to their service accounts.</p> <p>In the <code>actionJobServiceAccounts.namespaces</code> you may specify a list of namespaces where you plan to deploy custom resources. As a result, Helm will template and deploy service accounts, roles, etc. for action jobs to those namespaces.</p> <p>In the <code>rbac.controller</code> section you can specify additional namespaces to grant controller access on Secrets (<code>secretsNamespaces</code>) and to run Jobs (<code>jobsNamespaces</code>).</p>"},{"location":"guides/install/#controller-configuration","title":"Controller configuration","text":"<p>Two additional non-standard sections to pay attention to:</p> <ul> <li><code>controllerOptions</code>: startup controller configuration, or static config options that can't be changed without restart   of the controller.</li> <li><code>runtimeConfig</code>: dynamic controller config, Helm deploys it as ConfigMap in the controllers' namespace and controller   watches on changes in this CM and reloads values in case of changes.</li> </ul> <p>More details about configuration is in the dedicated section. Configuration provided in the default <code>runtimeConfig</code> section reflects the actual controllers' defaults and may be used as a handy template to set yours custom values.</p>"},{"location":"guides/install/#multi-namespace-installation","title":"Multi namespace installation","text":"<p>As we mentioned before, typical installation is single-namespaced: controller with all supplementary and custom resources are deployed to the single namespace. But in multi-tenant clusters you may need to spread custom resources (triggers, sources, actions) to different namespaces to reflect your responsibility model</p> <p>In this case, you have to add some additional customization to the Helm release config using the following variables:</p> <ul> <li><code>controllerNamespace</code>: namespace where controllers' resources should be deployed;</li> <li><code>createNamespace</code>: boolean value to specify whether to create controllers' namespace.</li> </ul> <p>The preferred way is to create controllers' namespace manually and specify it either in yours custom <code>values.yaml</code> or via <code>--set controllerNamespace=...</code> Helm command line option.</p> <p>Besides that, you have to add tenants namespaces to the lists for creating service accounts and RBAC resources, please refer to the comments in the chart <code>values.yaml</code> file, sections <code>actionJobServiceAccounts</code> and <code>rbac</code>.</p>"},{"location":"guides/install/#docker-images","title":"Docker images","text":"<p>All project Dockerfiles are self-contained and don't require any additional dependencies to build. So you can use the content of dockerfiles folder to build yours own variants of the images.</p> <p>There is a tiny handy script (<code>local-build.sh</code>) to build everything locally with <code>local</code> tag, which is default in the charts' <code>ci/local-default.yaml</code> test config.</p> <p>You can find information about command line parameters in the configuration section.</p>"},{"location":"guides/install/#build-from-sources","title":"Build from sources","text":"<p>To build controller from sources, you have to have Rust toolchain installed. Please read the official documentation to get know how to prepare Rust build environment.</p> <p>Clone project repository from GitHub:</p> <pre><code>git clone https://github.com/alex-karpenko/git-events-runner.git\n</code></pre> <p>To build and run controller locally with default Kubernetes config:</p> <pre><code># Build controller and gitrepo-cloner binaries\ncargo build\n\n# Install CRD manifests to the cluster\ncargo run --bin git-events-runner -- crds | kubectl apply -f -\n\n# Run controller locally with info loglevel\ncargo run --bin git-events-runner -- run -v\n</code></pre> <p>You can specify an alternative Kubernetes config file path using <code>KUBECONFIG</code> environment variable.</p>"},{"location":"intro/overview/","title":"What is Git Events Runner","text":"<p>As mentioned above this is custom Kubernetes operator which serves to:</p> <ul> <li>Watch on some Git repositories and run <code>Jobs</code> if something was changed in the watched branch/tag.</li> <li>Run the same <code>Jobs</code> when webhook has been received.</li> <li>Do the same just periodically even if nothing was changed.</li> </ul>"},{"location":"intro/overview/#how-it-works","title":"How it works","text":"<ul> <li>Central resources of the <code>Git Events Runner</code> are triggers, there are   two - <code>ScheduleTrigger</code>   and <code>WebhookTrigger</code>.</li> <li>Obviously triggers interact with some sources to watch on changes, there are two kinds   of sources: <code>GitRepo</code>   and <code>ClusterGitRepo</code>.</li> <li>Finally, if some trigger fires (something changes in the branch or just time arrived or webhook received) it pushes   third type of resource - actions - to perform its dedication and run the <code>Job</code> (yes,   it's just a classic Kubernetes Job) which is   described by <code>Action</code> and <code>ClusterAction</code>   resources.</li> </ul> <p>Detailed explanations of all custom resources with examples can be found in the Guides section.</p>"},{"location":"intro/overview/#typical-flow","title":"Typical flow","text":"<p>Imagine we need to run script <code>deploy.sh</code> from the root of Git repo <code>https://git.example.com/the-best-team/cool-project</code> when anything was changed in the <code>main</code> branch (we have fine-grained branch protection and no one can merge to the <code>main</code> without approvement). That script, for example, upgrades Helm release in our K8s cluster in the namespace of the trigger:</p> <pre><code>#!/bin/bash\n\n# 1st argument is path to the folder with Helm chart\n\nhelm upgrade ${TRIGGER_SOURCE_NAME} ${1} -f configs/values.yaml --install --wait &amp;&amp; \\\n    (echo \"Has been successfully deployed\"; exit 0) || \\\n    (echo \"Something went wrong\"; exit 1)\n</code></pre> <p>and we need to check for branch changes <code>every 5 minutes</code>.</p> <p>To implement this requirements (except putting script to the repo) we create three simple resources:</p> <ul> <li>GitRepo:</li> </ul> <pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: GitRepo\nmetadata:\n  name: cool-project-repo\n  namespace: default\nspec:\n  repoUri: https://git.example.com/the-best-team/cool-project.git\n  authConfig:\n    type: basic\n    secretRef:\n      name: cool-project-auth\n</code></pre> <ul> <li>ScheduleTrigger:</li> </ul> <pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: ScheduleTrigger\nmetadata:\n  name: cool-trigger\n  namespace: default\nspec:\n  sources:\n    kind: GitRepo\n    names:\n      - cool-project-repo\n    watchOn:\n      onChangeOnly: true\n      reference:\n        branch: main\n  schedule:\n    interval: 5m\n  action:\n    kind: Action\n    name: run-deploy-sh\n</code></pre> <ul> <li>Action:</li> </ul> <pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: Action\nmetadata:\n  name: run-deploy-sh\n  namespace: default\nspec:\n  actionJob:\n    args:\n      - ./deploy.sh\n      - ./chart/\n    serviceAccount: git-events-runner-jobs\n</code></pre> <p>Using these resources <code>Git Events Runner</code> does following for each repo mentioned in the list of sources of the trigger:</p> <ol> <li>Clone specified branch (main is here) of the repo using URI and credentials (if needed) defined in GitRepo resource.</li> <li>Compare the latest commit hash with previously stored value (from previous run, if it was).</li> <li>If hash differs it uses Action resource to create Job with two containers:<ul> <li>init (cloner) container runs special image which clones repo to volume shared with second (worker) container.</li> <li>worker container set current directory to folder with cloned repo and \"runs\" worker image with arguments specified   in Action resource.</li> </ul> </li> <li>Stores last commit hash for the next run.</li> <li>Repeats the same for each source in the trigger.</li> <li>Sleep for specified interval and repeats everything.</li> </ol> <p>Notes:</p> <ul> <li><code>GitRepo</code> and <code>Action</code> instances can be used by several different triggers, as well as <code>ScheduleTrigger</code> can refer     to several sources of some kind.</li> <li>If a source refers to some secret(s) with credentials (if needed) that secret(s) should be created separately.</li> </ul> <p>One more chance to run the same Job is to define WebhookTrigger like this one:</p> <pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: WebhookTrigger\nmetadata:\n  name: coll-trigger\n  namespace: default\nspec:\n  sources:\n    kind: GitRepo\n    names:\n      - cool-project-repo # the same as before\n    watchOn:\n      onChangeOnly: false # pay attention to this\n      reference:\n        branch: main\n  action:\n    kind: Action\n    name: run-deploy-sh # the same action\n  webhook:\n    multiSource: true\n    authConfig:\n      secretRef:\n        name: webhook-auth\n      key: token\n</code></pre> <p>Notice that we:</p> <ul> <li>Reused existing GitRepo and Action for another trigger, even of other type.</li> <li>Set <code>onChangeOnly</code> to <code>false</code> to force running Action every time trigger fires (webhook request received) even if   there were no changes in the main repo branch.</li> </ul>"},{"location":"intro/overview/#namespaced-vs-cluster-resources","title":"Namespaced vs cluster resources","text":"<p>Both types of triggers are namespaced resources. However, Acton and GitRepo have their cluster-level counterparts. This means:</p> <ul> <li>Triggers can refer to any kind of actions or sources: namespaced or cluster-wide.</li> <li>WebhookTrigger can use Secrets in its own namespace only.</li> <li>GitRepo can use Secrets in its own namespace only, but ClusterGitRepo can refer secrets in other namespaces but with   respect to controller's permissions.</li> <li>Both Action and ClusterAction can create Jobs in the trigger's namespace only.</li> </ul> <p>Cluster-wide sources and actions are useful:</p> <ul> <li>in multi-tenant clusters;</li> <li>to share restricted configs between tenants/namespaces;</li> <li>just to avoid repetitions of configuration.</li> </ul>"},{"location":"intro/overview/#security-aspects","title":"Security aspects","text":"<p>This is pretty risky to bring some code (shell or Python scripts, Ansible playbooks, etc.) to Kubernetes cluster and run it as a Job. So the first security concern is to ensure we use only code we trust to:</p> <ul> <li>At the Git side this can be guarantied by applying strict code review requirements, restrict permissions to merge code   to protected branches or to use protected tags.</li> <li>At the Git Events Runner side you should configure trigger to use only some specific (secured, restricted) branches   and tags.</li> </ul> <p>Second important aspect is permissions within Kubernetes cluster which operator uses by itself and to run Jobs. And there whole huge set of instruments provided by Kubernetes can (and should) be used:</p> <ul> <li>Role Based Access Control (RBAC) in conjunction with ServiceAccounts (SA).</li> <li>Running operator with its own SA but Jobs with their separate SAs.</li> <li>Restrictions inside Job containers.</li> <li>Using approved Job images only (ClusterAction as shared restricted resource).</li> </ul>"},{"location":"intro/overview/#differences-from-gitops","title":"Differences from GitOps","text":"<p>At the first glance, Git Events Runner has some similarities with GitOps, however actually it implements completely different approach.</p> <p>First of all, GitOps is about desired configuration of application (or infrastructure), and it's about actual state of application: main task of GitOps operator (let's call it so) is to make actual state the same as desired, and doesn't matter where were changes: at application side (actual state) or in the git repo with config (desired state). So GitOps operator reacts on changes at both sides: desired (git) and actual (application or infrastructure).</p> <p>Git Events Runner is also intended to react on changes at Git side but not at application/infrastructure (actual) side. This is a huge difference: we just use Git to store code, configs, etc. which we need to execute within Kubernetes cluster. So we even don't have such entity as \"actual state\": Git Events Runner is about \"changes as events\".</p> <p>Yes, theoretically it's possible to implement GitOps approach using Git Events Runner but lots of brilliant GitOps solutions are already implemented.</p>"},{"location":"intro/quick-start/","title":"Getting started","text":""},{"location":"intro/quick-start/#installation","title":"Installation","text":"<p>The easiest way to install Git Events Runner operator to your Kubernetes cluster is to use Helm chart. Add repo:</p> <pre><code>helm repo add alex-karpenko https://alex-karpenko.github.io/helm-charts\nhelm repo update\n</code></pre> <p>and install Helm release with default config to <code>git-events-runner</code> namespace:</p> <pre><code>helm install git-events-runner alex-karpenko/git-events-runner \\\n    --namespace git-events-runner --create-namespace\n</code></pre> <p>By default, Helm creates single replica controller, service accounts for controller and jobs in the release namespace with access to secrets in the release namespace only. For details of configuration please refer to default chart config and configuration section.</p>"},{"location":"intro/quick-start/#repository","title":"Repository","text":"<p>Now it's time to create our first GitRepo resource. Let's use this repo just for example. Create <code>controller-gitrepo.yaml</code> file with following content:</p> controller-gitrepo.yaml<pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: GitRepo\nmetadata:\n  name: git-events-runner-repo\n  namespace: git-events-runner\nspec:\n  repoUri: https://github.com/alex-karpenko/git-events-runner.git\n</code></pre> <p>and apply it to your cluster:</p> <pre><code>kubectl apply -f controller-gitrepo.yaml\n</code></pre> <p>That repository is public, so no authorization is needed. Please refer to detailed documentation to create more sophisticated resources with different security and transport options.</p> <p>All scripts and manifests for this quick start example can be found in the <code>docs/examples</code> folder.</p>"},{"location":"intro/quick-start/#action","title":"Action","text":"<p>Our example task is to upgrade... Git Events Runner controller in our cluster. Yes, it's possible, just for example, but in real life don't trust public repositories with content not under your control.</p> <p>For this purpose there is example script <code>docs/examples/upgrade-helm-release.sh</code>:</p> upgrade-helm-release.sh<pre><code>#!/bin/bash\n\nhelm repo add alex-karpenko https://alex-karpenko.github.io/helm-charts\nhelm repo update\n\nhelm upgrade git-events-runner alex-karpenko/git-events-runner --namespace git-events-runner\n</code></pre> <p>So our Action resource defines way to run that script:</p> upgrade-controller-action.yaml<pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: Action\nmetadata:\n  name: upgrade-controller\n  namespace: git-events-runner\nspec:\n  actionJob:\n    # default SA if isn't customized by Helm release config\n    serviceAccount: git-events-runner-action-job\n    args:\n      - /bin/bash\n      - docs/examples/upgrade-helm-release.sh\n</code></pre> <p>Push action resource to the cluster:</p> <pre><code>kubectl apply -f upgrade-controller-action.yaml\n</code></pre> <p>As usual, this example is pretty straightforward, to understand all possible ways to customize Action and ClusterAction please refer to detailed resources' documentation.</p>"},{"location":"intro/quick-start/#triggers","title":"Triggers","text":"<p>The next step is to create triggers which will be watching on changes in that repo and call our action to get an actual result. Let's create two triggers:</p> <ul> <li>ScheduleTrigger which checks our repository for changes in the <code>main</code>   branch every hour and upgrades our controller if anything were changed there.</li> <li>WebhookTrigger which does almost the same but regardless of changes in the   repo, just on our request and use <code>v0.1.0</code> tag (first stable at the time of writing) instead of <code>main</code> branch.</li> </ul> <p>Minimal versions of our example triggers look like these:</p> schedule-trigger.yaml<pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: ScheduleTrigger\nmetadata:\n  name: git-events-runner-trigger\n  namespace: git-events-runner\nspec:\n  sources:\n    kind: GitRepo\n    names:\n      - git-events-runner-repo\n    watchOn:\n      onChangeOnly: true # trigger action if repo changed only\n      reference:\n        branch: main\n  schedule:\n    interval: 1h\n  action:\n    kind: Action\n    name: upgrade-controller\n</code></pre> webhook-trigger.yaml<pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: WebhookTrigger\nmetadata:\n  name: git-events-runner-trigger\n  namespace: git-events-runner\nspec:\n  sources:\n    kind: GitRepo\n    names:\n      - git-events-runner-repo\n    watchOn:\n      onChangeOnly: false # trigger action regardless of changes\n      reference:\n        tag: v0.1.0\n  webhook:\n    multiSource: false\n    authConfig:\n      secretRef:\n        name: webhook-auth\n      key: token\n  action:\n    kind: Action\n    name: upgrade-controller\n</code></pre> <p>Apply to the cluster:</p> <pre><code>kubectl apply -f schedule-trigger.yaml\nkubectl apply -f webhook-trigger.yaml\n</code></pre> <p>As you can see, our WebhookTrigger refers to the Secret with webhook token, let's create example token. You clearly understand in real life secrets should be created in secret way:</p> <pre><code>kubectl create secret generic webhook-auth --namespace git-events-runner \\\n    --from-literal token=\"some-super-secret-token\"\n</code></pre> <p>To get more details about triggers configuration, please look into triggers' reference in this guide.</p>"},{"location":"intro/quick-start/#quick-result","title":"Quick result","text":"<p>Let's look into our cluster. Just after creating of our first ScheduleTrigger controller's Helm release was upgraded and trigger got status with:</p> <ul> <li>last time of trigger run;</li> <li>time of the last changes in the source branch;</li> <li>commit hash on which trigger run action.</li> </ul> <pre><code>kubectl describe scheduletrigger git-events-runner-trigger -n git-events-runner\n</code></pre> <pre><code>Name: git-events-runner-trigger\nNamespace: git-events-runner\nLabels: &lt;none&gt;\nAnnotations: &lt;none&gt;\nAPI Version: git-events-runner.rs/v1alpha1\nKind: ScheduleTrigger\nMetadata:\n  Creation Timestamp: 2024-05-18T17:19:16Z\n  Finalizers:\n    scheduletriggers.git-events-runner.rs\n  Generation: 1\n  Resource Version: 1042\n  UID: 790f5bf6-b757-4b41-bdec-1968a1f03074\nSpec:\n  Action:\n    Kind: Action\n    Name: upgrade-controller\n  Schedule:\n    Interval: 1m\n  Sources:\n    Kind: GitRepo\n    Names:\n      git-events-runner-repo\n    Watch On:\n      On Change Only: true\n      Reference:\n        Branch: improve-docs\nStatus:\n  Checked Sources:\n    Git - Events - Runner - Repo:\n      Changed: 2024-05-18T17:19:17Z\n      Commit Hash: 8803515889f034ec9aa22b0234ebd950f8f1a5e8\n  Last Run: 2024-05-18T17:19:17Z\n  State: Idle\nEvents: &lt;none&gt;\n</code></pre> <p>Looks good, our trigger run recently on <code>8803515889f034ec9aa22b0234ebd950f8f1a5e8</code> commit. Let's examine pods and jobs in the controllers' namespace:</p> <pre><code>kubectl get pods -n git-events-runner\n</code></pre> <pre><code>NAME                                          READY   STATUS    RESTARTS   AGE\ngit-events-runner-86d475584d-nfcwm            1/1     Running   0          2m36s\nupgrade-controller-20240518-171917-ae-h4jf4   0/1     Error     0          109s\n</code></pre> <pre><code>kubectl get jobss -n git-events-runner\n</code></pre> <pre><code>NAME                                    COMPLETIONS   DURATION   AGE\nupgrade-controller-20240518-171917-ae   0/1           6m18s      115s\n</code></pre> <p>Something went wrong with the job, let's try to investigate deeply:</p> <pre><code>kubectl logs -n git-events-runner upgrade-controller-20240518-171917-ae-h4jf4\n</code></pre> <pre><code>Defaulted container \"action-worker\" out of: action-worker, action-cloner (init)\n\"alex-karpenko\" has been added to your repositories\nHang tight while we grab the latest from your chart repositories...\n...Successfully got an update from the \"alex-karpenko\" chart repository\nUpdate Complete. \u2388Happy Helming!\u2388\nError: UPGRADE FAILED: query: failed to query with labels: secrets is forbidden: User \"system:serviceaccount:git-events-runner:git-events-runner-action-job\" cannot list resource \"secrets\" in API group \"\" in the namespace \"git-events-runner\"\n</code></pre> <p>It looks like Job's ServiceAccount <code>git-events-runner-action-job</code> has no enough permissions to upgrade Helm release because there are lots of various resources are involved: deployment, service accounts, roles, secrets, etc. But default ServiceAccount is quite restricted and has minimal permissions just to clone source repo.</p> <p>So if we need to do such a powerful job like upgrading Helm release, we have to add some power to our Action. Right now (just for our example Action) the easiest way to empower it is to bind an additional role to the existing service account, like below:</p> power-job-role.yaml<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: power-jobs\n  namespace: git-events-runner\nrules:\n  - apiGroups:\n      - apps\n    resources:\n      - deployments\n    verbs:\n      - \"*\"\n  - apiGroups:\n      - \"\"\n    resources:\n      - secrets\n      - serviceaccounts\n      - configmaps\n      - services\n    verbs:\n      - \"*\"\n  - apiGroups:\n      - policy\n    resources:\n      - poddisruptionbudgets\n    verbs:\n      - \"*\"\n  - apiGroups:\n      - rbac.authorization.k8s.io\n    resources:\n      - roles\n      - rolebindings\n    verbs:\n      - \"*\"\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: power-jobs\nrules:\n  - apiGroups:\n      - apiextensions.k8s.io\n    resources:\n      - customresourcedefinitions\n    verbs:\n      - \"*\"\n  - apiGroups:\n      - rbac.authorization.k8s.io\n    resources:\n      - clusterroles\n      - clusterrolebindings\n    verbs:\n      - \"*\"\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: power-jobs\n  namespace: git-events-runner\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: power-jobs\nsubjects:\n  - kind: ServiceAccount\n    name: git-events-runner-action-job\n    namespace: git-events-runner\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: power-jobs\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: power-jobs\nsubjects:\n  - kind: ServiceAccount\n    name: git-events-runner-action-job\n    namespace: git-events-runner\n</code></pre> <pre><code>kubectl apply -f power-job-role.yaml \n</code></pre> <p>And instead of waiting an hour for the next ScheduleTrigger run, let's trigger it via webhook. In real life, you'll open access to webhook service via Ingress, but right now we can use <code>port-forward</code> feature of <code>kubectl</code> to jump directly into the cluster. Let's create port forwarding:</p> <pre><code>kubectl port-forward service/git-events-runner 8080 -n git-events-runner --address=localhost \n</code></pre> <p>and call our WebhookTrigger in another terminal window by path like <code>/namespace/trigger-name/source-name</code>:</p> <pre><code>curl -X POST -H 'x-trigger-auth: some-super-secret-token' http://localhost:8080/git-events-runner/git-events-runner-trigger/git-events-runner-repo\n</code></pre> <pre><code>{\"status\":\"ok\",\"message\":\"job has been scheduled\",\"task_id\":\"2490ea84-ce5d-4a42-8864-d33145770134\"}\n</code></pre> <p>Cool! We got expected response about job scheduling, let's check the result:</p> <pre><code>kubectl get pods -n git-events-runner\n</code></pre> <pre><code>NAME                                          READY   STATUS      RESTARTS   AGE\ngit-events-runner-86d475584d-nfcwm            1/1     Running     0          10m\nupgrade-controller-20240518-171917-ae-h4jf4   0/1     Error       0          12m\nupgrade-controller-20240518-175031-yb-47r97   0/1     Completed   0          30s\n</code></pre> <p>It looks like the second job completed successfully:</p> <pre><code>kubectl logs upgrade-controller-20240518-175031-yb-47r97 -n git-events-runner\n</code></pre> <pre><code>Defaulted container \"action-worker\" out of: action-worker, action-cloner (init)\n\"alex-karpenko\" has been added to your repositories\nHang tight while we grab the latest from your chart repositories...\n...Successfully got an update from the \"alex-karpenko\" chart repository\nUpdate Complete. \u2388Happy Helming!\u2388\nRelease \"git-events-runner\" has been upgraded. Happy Helming!\nNAME: git-events-runner\nLAST DEPLOYED: Sat May 18 17:50:35 2024\nNAMESPACE: git-events-runner\nSTATUS: deployed\nREVISION: 2\n</code></pre> <p>Since both schedule and webhook triggers use the same service account, the next schedule trigger run also will be completed, but it will create an actual job only in case if something changed in the source repo. All other runs it will just watch for such changes and do nothing.</p> <p>You can find all possible installation options in the detailed installation guide.</p>"},{"location":"intro/state/","title":"Current state of development","text":"<p>This is working beta which I develop and support in spare time.</p> <p>Projects' repository: https://github.com/alex-karpenko/git-events-runner</p> <ul> <li>Project is in active development, any suggestions to improve it are welcome, just create   an Issue in the project at GitHub.</li> <li>Bugs are possible, please report an Issue.   But check for know bugs before to avoid repeating.</li> <li>I do my best to fix bugs and implement new features, but delays are possible.</li> <li>Contributors are welcome, please create a Pull request with suggested changes.</li> <li>Changes to Custom Resources Definitions (CRD) are possible, but probably with API version change as well.</li> </ul> <p>List of changes, plans and known bugs you can find in the Development section.</p>"},{"location":"resources/actions/","title":"Actions","text":"<p>Describes actions what should be run as reaction to fired trigger.</p> <p>There are only two differences between these resources:</p> <ul> <li>ClusterAction is a cluster wide resource, but Action is namespaced one.</li> <li><code>sourceOverride</code> section of the Action can refer to any kind of sources whereas ClusterAction can use cluster scoped   sources only (ClusterGitRepo).</li> </ul> <p>Actual defaults that will be used instead of omitted fields depend on the values from dynamic controllers' config, so defaults mentioned below are actually defaults of the controller but may be overridden in controllers' configuration.</p> <p>Below are examples of each resource kind with detailed comments. You see that minimal action resource may look like:</p> <pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: Action\nmetadata:\n  name: some-action\n  namespace: default\nspec:\n  actionJob:\n</code></pre> <p>and in this case, all defaults will be applied: default images, entrypoints, arguments, etc.</p>"},{"location":"resources/actions/#action","title":"Action","text":"Action<pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: Action\nmetadata:\n  name: some-action\n  namespace: default\nspec:\n  # Optional definition of the Job to run to complete this action\n  actionJob:\n    # Optional entrypoint of the worker container,\n    # Default is ENTRYPOINT of the worker image\n    command: entrypoint.sh\n    # Optional list of the worker container arguments\n    # Default is CMD of the worker image\n    args:\n      - ./runme.sh\n      - with\n      - some\n      - parameters\n    # Optional action worker image reference\n    # Default is `ghcr.io/alex-karpenko/git-events-runner/action-worker`\n    # with tag of the current controller version\n    actionImage: ghcr.io/alex-karpenko/git-events-runner/action-worker:latest\n    # Optional action gitrepo cloner image reference\n    # Default is `ghcr.io/alex-karpenko/git-events-runner/gitrepo-cloner`\n    # with tag of the current controller version\n    clonerImage: ghcr.io/alex-karpenko/git-events-runner/gitrepo-cloner:latest\n    # Kubernetes Service account to use for the Job\n    # No defaults, so the default namespace service account will be used\n    serviceAccount: git-events-runner-action-job\n    # Folder to clone repo content to, and this is workdir of the worker container\n    # Default is `/action_workdir`\n    workdir: /action_workdir\n    # Turn on debug in `gitrepo-cloner` container,\n    # Sometimes it's useful to facilitate issues investigation during repo cloning\n    # Default is `false`\n    enableClonerDebug: false\n    # By default, `gitrepo-cloner` removes .git folder from the workdir after cloning,\n    # to preserve storage space (usually this folder is the largest one) and to hide\n    # details about repo from the worker.\n    # This option allows access to the .git folder in worker container.\n    preserveGitFolder: false\n\n  # By using this optional feature, we can substitute repo/commit which triggers this action,\n  # by some other predefined repo/commit. This is useful to do when we need to run something\n  # not from triggers' repo as reaction to triggers' repo changes.\n  # All fields are mandatory if you use this feature.\n  sourceOverride:\n    # Type of the source,\n    # Allowed values: GitRepo, ClusterGitRepo\n    kind: GitRepo\n    # Name of the source\n    name: git-repo-name\n    # Reference, which should be used in the overridden source,\n    # Allowed keys: branch, tag and commit with corresponding values.\n    # These keys are mutually exclusive.\n    reference:\n      # Use particular branch as reference\n      branch: main\n      # Use particular tag as reference\n      tag: v0.1.0\n      # Use exact commit hash as reference\n      commit: 92abcd3fc4082ed5e53f12b383e14580b83dcff3\n</code></pre>"},{"location":"resources/actions/#clusteraction","title":"ClusterAction","text":"ClusterAction<pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: ClusterAction\nmetadata:\n  name: some-action\nspec:\n  # Optional definition of the Job to run to complete this action\n  actionJob:\n    # Optional entrypoint of the worker container,\n    # Default is ENTRYPOINT of the worker image\n    command: entrypoint.sh\n    # Optional list of the worker container arguments\n    # Default is CMD of the worker image\n    args:\n      - ./runme.sh\n      - with\n      - some\n      - parameters\n    # Optional action worker image reference\n    # Default is `ghcr.io/alex-karpenko/git-events-runner/action-worker`\n    # with tag of the current controller version\n    actionImage: ghcr.io/alex-karpenko/git-events-runner/action-worker:latest\n    # Optional action gitrepo cloner image reference\n    # Default is `ghcr.io/alex-karpenko/git-events-runner/gitrepo-cloner`\n    # with tag of the current controller version\n    clonerImage: ghcr.io/alex-karpenko/git-events-runner/gitrepo-cloner:latest\n    # Kubernetes Service account to use for the Job\n    # No defaults, so the default namespace service account will be used\n    serviceAccount: git-events-runner-action-job\n    # Folder to clone repo content to, and this is workdir of the worker container\n    # Default is `/action_workdir`\n    workdir: /action_workdir\n    # Turn on debug in `gitrepo-cloner` container,\n    # Sometimes it's useful to facilitate issues investigation during repo cloning\n    # Default is `false`\n    enableClonerDebug: false\n    # By default, `gitrepo-cloner` removes .git folder from the workdir after cloning,\n    # to preserve storage space (usually this folder is the largest one) and to hide\n    # details about repo from the worker.\n    # This option allows access to the .git folder in worker container.\n    preserveGitFolder: false\n\n  # By using this optional feature, we can substitute repo/commit which triggers this action,\n  # by some other predefined repo/commit. This is useful to do when we need to run something\n  # not from triggers' repo as reaction to triggers' repo changes.\n  # All fields are mandatory if you use this feature.\n  sourceOverride:\n    # Type of the source,\n    # Allowed values: ClusterGitRepo only\n    kind: ClusterGitRepo\n    # Name of the source\n    name: git-repo-name\n    # Reference, which should be used in the overridden source,\n    # Allowed keys: branch, tag and commit with corresponding values.\n    # These keys are mutually exclusive.\n    reference:\n      # Use particular branch as reference\n      branch: main\n      # Use particular tag as reference\n      tag: v0.1.0\n      # Use exact commit hash as reference\n      commit: 92abcd3fc4082ed5e53f12b383e14580b83dcff3\n</code></pre>"},{"location":"resources/sources/","title":"Sources","text":"<p>Describes a source to watch on changes in it. GitRepo and ClusterGitRepo are implemented so far.</p> <p>Below are examples of each resource kind with detailed comments.</p> <p>There are only two differences between these resources:</p> <ol> <li>ClusterGitRepo is a cluster wide resource, but GitRepo is namespaced one, sounds pretty obvious.</li> <li>GitRepo can refer Secrets in its own namespace only, whereas ClusterGitRepo can use Secrets in any namespace (if this    is permitted by one of its roles).</li> </ol>"},{"location":"resources/sources/#gitrepo","title":"GitRepo","text":"GitRepo<pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: GitRepo\nmetadata:\n  name: git-repo-name\n  namespace: default\nspec:\n  # The only mandatory field\n  # Allowed schemas: https, http, ssh, git\n  # Examples:\n  #   - https://github.com/alex-karpenko/test-git-events-runner.git\n  #   - http://github.com/alex-karpenko/test-git-events-runner.git\n  #   - git@github.com:alex-karpenko/git-events-runner.git\n  #   - ssh://mylogin@github.com/alex-karpenko/test-git-events-runner\n  repoUri: https://github.com/alex-karpenko/test-git-events-runner.git\n\n  # Optional TLS transport config\n  tlsConfig:\n    # Skip SSL verification at all, default is `false`\n    noVerifySsl: false\n    # Optional repo's endpoint custom CA certificate config\n    # Allowed for https kind of the `repoUri` only\n    caCert:\n      # Reference to the Secret with CA certificate in the GitRepo's namespace\n      secretRef:\n        # Name of the secret, mandatory if caCert is defined\n        name: ca-cert-secret\n      # Key name in the Secret with CA certificate\n      # Optional, default is `ca.crt`\n      key: ca.crt\n\n  # Optional authorization config\n  authConfig:\n    # Auth type, mandatory if `authConfig` is defined\n    # Allowed values:\n    #   - basic: classic basic auth username and password,\n    #     allowed for https and http (insecure!) schemas only,\n    #     adds Authorization header like \"Authorization: Basic &lt;base64 encoded username:password pair&gt;\"\n    #\n    #   - ssh: authenticate using ssh private key, usually login should be specified in the URI\n    #     allowed in ssh anf git schemas only\n    #\n    #   - token: custom token in Authorization header,\n    #     allowed for https and http (insecure!) schemas only,\n    #     adds Authorization header like \"Authorization: &lt;token&gt;\"\n    type: basic\n    # Reference to the Secret with auth credentials\n    # Mandatory if `authConfig` is defined\n    secretRef:\n      # Name of the secret, mandatory if `authConfig` is defined\n      name: git-repo-secret\n    # Optional key names in the Secret which contains the necessary credentials\n    # Redefine it if key names differ from the default\n    keys:\n      # Below are defaults\n      username: username # mandatory for a basic auth type\n      password: password # mandatory for a basic auth type\n      token: token       # mandatory for a token auth type\n      privateKey: ssh-privatekey # mandatory for an ssh auth type\n</code></pre>"},{"location":"resources/sources/#clustergitrepo","title":"ClusterGitRepo","text":"ClusterGitRepo<pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: ClusterGitRepo\nmetadata:\n  name: git-repo-name\nspec:\n  # The only mandatory field\n  # Allowed schemas: https, http, ssh, git\n  # Examples:\n  #   - https://github.com/alex-karpenko/test-git-events-runner.git\n  #   - http://github.com/alex-karpenko/test-git-events-runner.git\n  #   - git@github.com:alex-karpenko/git-events-runner.git\n  #   - ssh://mylogin@github.com/alex-karpenko/test-git-events-runner\n  repoUri: https://github.com/alex-karpenko/test-git-events-runner.git\n\n  # Optional TLS transport config\n  tlsConfig:\n    # Skip SSL verification at all, default is `false`\n    noVerifySsl: false\n    # Optional repo's endpoint custom CA certificate config\n    # Allowed for https kind of the `repoUri` only\n    caCert:\n      # Reference to the Secret with CA certificate in the GitRepo's namespace\n      secretRef:\n        # Name of the secret, mandatory if caCert is defined\n        name: ca-cert-secret\n        # Optional namespace of the Secret,\n        # default is the namespace of the trigger which uses this resource\n        namespace: default\n      # Key name in the Secret with CA certificate\n      # Optional, default is `ca.crt`\n      key: ca.crt\n\n  # Optional authorization config\n  authConfig:\n    # Auth type, mandatory if `authConfig` is defined\n    # Allowed values:\n    #   - basic: classic basic auth username and password,\n    #     allowed for https and http (insecure!) schemas only,\n    #     adds Authorization header like \"Authorization: Basic &lt;base64 encoded username:password pair&gt;\"\n    #\n    #   - ssh: authenticate using ssh private key, usually login should be specified in the URI\n    #     allowed in ssh anf git schemas only\n    #\n    #   - token: custom token in Authorization header,\n    #     allowed for https and http (insecure!) schemas only,\n    #     adds Authorization header like \"Authorization: &lt;token&gt;\"\n    type: basic\n    # Reference to the Secret with auth credentials\n    # Mandatory if `authConfig` is defined\n    secretRef:\n      # Name of the secret, mandatory if `authConfig` is defined\n      name: git-repo-secret\n      # Optional namespace of the Secret,\n      # default is the namespace of the trigger which uses this resource\n      namespace: default\n    # Optional key names in the Secret which contains the necessary credentials\n    # Redefine it if key names differ from the default\n    keys:\n      # Below are defaults\n      username: username # mandatory for a basic auth type\n      password: password # mandatory for a basic auth type\n      token: token       # mandatory for a token auth type\n      privateKey: ssh-privatekey # mandatory for an ssh auth type\n</code></pre>"},{"location":"resources/triggers/","title":"Triggers","text":"<p>Both types of the triggers are almost identical except one principal section:</p> <ul> <li><code>ScheduleTrigger</code> has a schedule section which describes how often it should check sources for changes.</li> <li><code>WebhookTrigger</code> has a webhook section which describes triggers behavior on HTTP requests.</li> </ul> <p>sources section contains list (one or more) of sources to check. Every time ScheduleTrigger runs, it checks all sources one by one and creates Job for each source that has been changed from the previous check.</p> <p>It's possible to specify additional constrain on the source check: name of the file, which should be changed to make trigger fired. Adding or removing file, as well as changing its hash if file is present, means that source has been changed.</p> <p>WebhookTrigger can be called by specifying path to the trigger in one of the two forms:</p> <ul> <li>By trigger name without a source name: <code>/namespace/trigger</code>, like <code>/default/trigger-example</code>.   In this case, trigger checks all defined sources one by one like a ScheduleTrigger.</li> <li>With full source name: /namespace/trigger/source, like <code>/default/trigger-example/source-repo-1</code>.   In this case, trigger check specified source only.</li> </ul> <p>Second form is disabled by default to avoid possible unpredictable workload burst, and may be enabled by <code>multiSource</code> flag.</p> <p>If <code>authConfig</code> section of the WebhookTrigger is defined, authorization header should be present in each request to the trigger. Header name may be changed.</p>"},{"location":"resources/triggers/#scheduletrigger","title":"ScheduleTrigger","text":"ScheduleTrigger<pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: ScheduleTrigger\nmetadata:\n  name: trigger-example\n  namespace: default\nspec:\n  # Mandatory section,\n  # It specifies a list of the sources to watch and optionally watching config\n  sources:\n    # Kind of the sources,\n    # Allowed values: GitRepo and ClusterGitRepo\n    kind: GitRepo\n    # List of the sources to watch on. Trigger will clone each repo one by one,\n    # and check for changes each repo separately.\n    #\n    # Trigger calls action for each source separately,\n    # so if all three sources (in the example below) were changed -\n    # trigger calls action three times consecutively.\n    names:\n      - source-repo-1\n      - source-repo-2\n      - source-repo-3\n    # Optional watching config\n    watchOn:\n      # Run action if repo reference was changes only,\n      # and ignore it if the current commit is the same\n      # as during the previous run.\n      #\n      # If this field is `false`, trigger will call action each time\n      # it runs regardless of changes in the source.\n      #\n      # Default is `true`\n      onChangeOnly: true\n      # Which referent to watch on\n      # Allowed keys: branch, tag and commit with corresponding values.\n      # These keys are mutually exclusive.\n      # Default is `branch: main`\n      reference:\n        branch: main # default\n        tag: v0.1.0\n        commit: 92abcd3fc4082ed5e53f12b383e14580b83dcff3\n      # Optionally, besides checking for changes in the whole repo,\n      # trigger can check for changes in some particular file.\n      # Hash of the file matters, but modification time doesn't.\n      #\n      # Logic for calling action is:\n      # - if both reference and file were changed/add/removed - call the action,\n      # - if reference was changed, but the file wasn't - don't call the cation,\n      # - if reference was changed, but the file isn't present - call the action.\n      file: doc/examples/scheduletrigger.yaml\n\n  # Mandatory schedule that defines when sources should be checked for changes.\n  # Allowed keys: interval, cron.\n  # These keys are mutually exclusive.\n  #\n  # Interval defines time in human-readable format (like 10s, 5m, 20h, 5h30m25s)\n  # between the finish of the previous run and start of the next run.\n  #\n  # Cron defines classic cron schedule.\n  # It uses seven items expression: seconds, minutes, hours, days (month), months, days (week), years.\n  # Seconds and years can be omitted: if an expression has 5 items, it runs at second 0 every year;\n  # if it has 6 items - the first item defines seconds.\n  schedule:\n    interval: 1m\n    cron: \"*/15 9-20 * * 1-5\"\n\n  # Mandatory definition of the Action to use for this trigger.\n  action:\n    # TYpe of the action,\n    # Allowed values: Action, ClusterAction\n    kind: Action\n    # Actions' name\n    name: some-action\n\n# Current trigger status\nstatus:\n  # Current state, possible values:\n  # - Idle: indicates that trigger is in waiting for event state\n  # - Running: trigger runs sources check loop\n  # - WrongConfig: some misconfiguration of the trigger prevents running,\n  state: Idle\n  # Timestamp of last triggers' run\n  lastRun: 2024-05-20T01:02:03Z\n  # Dictionary with results of all sources checks\n  checkedSources:\n    source-repo-1:\n      # Last hash discovered in the source/reference\n      commitHash:\n      # Last hash of the optional file in the repo\n      fileHash:\n      # Timestamp of the last sources' change\n      changed: 2024-05-20T01:02:01Z\n</code></pre>"},{"location":"resources/triggers/#webhooktrigger","title":"WebhookTrigger","text":"WebhookTrigger<pre><code>apiVersion: git-events-runner.rs/v1alpha1\nkind: WebhookTrigger\nmetadata:\n  name: trigger-example\n  namespace: default\nspec:\n  # Mandatory section,\n  # It specifies a list of the sources to watch and optionally watching config\n  sources:\n    # Kind of the sources,\n    # Allowed values: GitRepo and ClusterGitRepo\n    kind: GitRepo\n    # List of the sources to watch on. Trigger will clone each repo one by one,\n    # and check for changes each repo separately.\n    #\n    # Trigger calls action for each source separately,\n    # so if all three sources (in the example below) were changed -\n    # trigger calls action three times consecutively.\n    names:\n      - source-repo-1\n      - source-repo-2\n      - source-repo-3\n    # Optional watching config\n    watchOn:\n      # Run action if repo reference was changes only,\n      # and ignore it if the current commit is the same\n      # as during the previous run.\n      #\n      # If this field is `false`, trigger will call action each time\n      # it runs regardless of changes in the source.\n      #\n      # Default is `true`\n      onChangeOnly: true\n      # Which referent to watch on\n      # Allowed keys: branch, tag and commit with corresponding values.\n      # These keys are mutually exclusive.\n      # Default is `branch: main`\n      reference:\n        branch: main # default\n        tag: v0.1.0\n        commit: 92abcd3fc4082ed5e53f12b383e14580b83dcff3\n      # Optionally, besides checking for changes in the whole repo,\n      # trigger can check for changes in some particular file.\n      # Hash of the file matters, but modification time doesn't.\n      #\n      # Logic for calling action is:\n      # - if both reference and file were changed/add/removed - call the action,\n      # - if reference was changed, but the file wasn't - don't call the cation,\n      # - if reference was changed, but the file isn't present - call the action.\n      file: doc/examples/scheduletrigger.yaml\n\n  # Mandatory definition of the webhook behavior,\n  webhook:\n    # If `true`, it's possible to call checks for all triggers' sources\n    # by single call to `/namespace/trigger`\n    # as well as call to a single source by `/namespace/trigger/source`\n    # If `false`, single source calls are allowed only.\n    # Default is `false`\n    multiSource: false\n    # Optionals (by strongly recommended) section with webhook authentication config.\n    authConfig:\n      # Mandatory reference to the Secret with auth token.\n      secretRef:\n        # Name of the secret\n        name: webhook-auth\n      # Mandatory key name in the Secret which contains authentication token\n      key: token\n      # Optional HTTP request header with auth token\n      # Default is `x-trigger-auth`\n      header: x-trigger-auth\n\n  # Mandatory definition of the Action to use for this trigger.\n  action:\n    # TYpe of the action,\n    # Allowed values: Action, ClusterAction\n    kind: Action\n    # Actions' name\n    name: some-action\n\n# Current trigger status\nstatus:\n  # Current state, possible values:\n  # - Idle: indicates that trigger is in waiting for event state\n  # - Running: trigger runs sources check loop\n  # - WrongConfig: some misconfiguration of the trigger prevents running,\n  state: Idle\n  # Timestamp of last triggers' run\n  lastRun: 2024-05-20T01:02:03Z\n  # Dictionary with results of all sources checks\n  checkedSources:\n    source-repo-1:\n      # Last hash discovered in the source/reference\n      commitHash:\n      # Last hash of the optional file in the repo\n      fileHash:\n      # Timestamp of the last sources' change\n      changed: 2024-05-20T01:02:01Z\n</code></pre>"}]}